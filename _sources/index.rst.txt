HermesBDD
=========

HermesBDD is a parallel multi-core, and multi-platform, library of `Binary Decision Diagrams <https://en.wikipedia.org/wiki/Binary_decision_diagram>`_ 
written in C++. It focuses on high performance, usability, and correctness.

So how did HermesBDD get its name? In Greek mythology, Hermes, son of Zeus and 
the nymph Maia, was the messenger of the gods, because he was as swift as the wind. 
Hence the name HermesBDD, meaning an extremely fast and light BDD library.

The main repository of HermesBDD is https://github.com/luigicapogrosso/HermesBDD.

Dependencies
============

HermesBDD has the following dependencies:

- **CMake**, for compiling;
- **Sphinx**, for documentation generation.

For further information about CMake and Sphinx, check the following `1 <https://cmake.org/>`_ and 
`2 <https://www.sphinx-doc.org/en/master/>`_ documentation page, respectively.

Building
========

The library is tested for compilation using GCC (minimum required: 10.2), Clang 
(minimum required: 11.0), and MSVC (minimum required: 19.20). To build the library 
from sources in a clean way, it is preferable that you set up a build subdirectory, say:

.. code:: bash

    mkdir build && cd build

Then, you can prepare the build environment, choosing a Release build for 
maximum performance:

.. code:: bash

    cmake .. -DCMAKE_BUILD_TYPE=Release

At this point, if no error arises, you can build with:

.. code:: bash

    cmake --build .

CMake options
-------------

Available options are:

.. list-table::
   :widths: 25 50 25
   :header-rows: 1

   * - Option
     - Description
     - Default Value
   * - NO_CACHE
     - Do not use cache
     - OFF
   * - NO_THREAD
     - Do not use thread
     - OFF
   * - COVERAGE
     - Enable coverage reporting
     - OFF

Using HermesBDD
===============

To import the library, add the following line to your file:

.. code:: c

    #include <hermesbdd.h>

Getting Started
--------------------------

A simple use of the library is shown below:

.. code-block:: c

  #include <cassert>
  #include <hermesbdd.h>

  int main()
  {
      // The True terminal.
      BDD one = BDD::bdd_true;
      // The False terminal.
      BDD zero = BDD::bdd_false;

      // Create a BDD variable x_0.
      BDD a(0);
      // Create a BDD variable x_1.
      BDD b(1);

      // Compute !a and check if !!a is really a.
      BDD not_a = !a;
      assert((!not_a) == a);

      // Compute a & b and !(!a ^ !b) and check if they are equivalent.
      BDD a_and_b = a & b;
      BDD not_not_a_or_not_b = !((!a) | (!b));
      assert(a_and_b == not_not_a_or_not_b);

      // Compute !BDD(1) and nithvar(1) and check if they are equivalent.
      BDD c(1);
      BDD not_c = !c;

      BDD d;
      d = d.nithvar(1);
      assert(not_c == d);

      return 0;
  }

Basic HermesBDD functionality
-----------------------------

To create new BDDs, you can use:

- ``BDD(v)``           : representation of literal '<v>'.
- ``BDD nithvar(v)``   : representation of the negation of literal '<v>'.
- ``BDD(node, dummy)`` : '<bdd>' constructor that does not require creation of a node.
- ``BDD::bdd_true``    : representation of constant 'true'.
- ``BDD::bdd_false``   : representation of constant 'false'.

The following basic BDD operations are implemented:

- ``bdd_a == bdd_b``             : compute '<bdd_a> == <bdd_b>'.
- ``!bdd_a``                     : compute the negation of <bdd_a>.
- ``bdd_a & bdd_b``              : compute '<bdd_a> and <bdd_b>'.
- ``bdd_a &= bdd_b``             : compute '<bdd_a> and eq. <bdd_b>'.
- ``bdd_a | bdd_b``              : compute '<bdd_a> or <bdd_b>'.
- ``bdd_a |= bdd_b``             : compute '<bdd_a> or eq. <bdd_b>'.
- ``bdd_a ^ bdd_b``              : compute '<bdd_a> xor <bdd_b>'.
- ``bdd_a ^= bdd_b``             : compute '<bdd_a> xor eq. <bdd_b>'.
- ``bdd_a > bdd_b``              : compute '<bdd_a> then <bdd_b>'.
- ``bdd_a >= bdd_b``             : compute '<bdd_a> then eq. <bdd_b>'.
- ``bdd_a < bdd_b``              : compute '<bdd_b> then <bdd_a>'.
- ``bdd_a <= bdd_b``             : compute '<bdd_b> then eq. <bdd_a>'.
- ``ITE(A, B, C)``               : compute 'if <A> then <B> else <C>' with cache support.
- ``ITE_without_cache(A, B, C)`` : compute 'if <A> then <B> else <C>' without cache support.

Tests
=====

The following tests can be found in the ``tests/`` subdirectory. 

Queens
------

Solves the following problem:

*Given N, then in how many ways can N queens be placed on an N x N chess board 
without threatening eachother?*

Our implementation of these benchmarks are based on the description of 
`Kunkle10 <https://dl.acm.org/doi/abs/10.1145/1837210.1837222>`_. We construct 
an BDD row-by-row that represents whether the row is in a legal state: is at 
least one queen placed on each row and is it also in no conflicts with any 
other? On the accumulated BDD we then count the number of satisfying 
assignments.

HermesBDD
---------

The file ``test_hermesbdd.cpp`` contains a toy program that uses the C++ objects to
perform basic BDD manipulation.

ITE
---

Finally, the file ``test_ITE.cpp`` contains toy program that checks the 
correctness of all the ITE operators.

Authors
=======

*Luigi Capogrosso* -- PhD at Politecnico di Torino, Italy, luigi.capogrosso@polito.it.

*Luca Geretti* -- Assistant Professor at University of Verona, Italy, luca.geretti@univr.it.
